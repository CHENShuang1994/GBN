#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= idex;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_n.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃGBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500)
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}
#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SED_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->t_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//***********************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStarup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_POR,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Slep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}

#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//*********************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	ele
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemor(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(bufer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizef(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}
#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: gtCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Methd: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrerver.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Öºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf(Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index =(i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(equit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
				case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
					{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE =20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvaiable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(saData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(bffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë  ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize   recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500)
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int otalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		returnfalse;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck;i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ictlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQSIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//ÊÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);urSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstrea>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
voidtimeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int min(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	adrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from cient: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool rnFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
							curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿ÚóĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,szeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
/ Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
	printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
						//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µp = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsgned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockSerer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	ici.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCoun = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = alse;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: stat addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockSerer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// ualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Retuns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i]= TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packe is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
						++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d%d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WINDSIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ocket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!";
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&adrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvilable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (aitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeqÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
/ Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Wnsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt);
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬serer ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&lngth);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//***********************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//***********************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_IZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKDDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking fo command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸fer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿Úº
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizef(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i= 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequsted;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADD*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTim(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case ://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								sage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClent),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡Éèª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Metho: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Ê¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(OBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢Í½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client»Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sckServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢Ë¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
				rAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(urAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 102;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the proess\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
							break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							prntf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptim
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//***********************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
	curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200)
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hand stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
							//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 0£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p>tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Metf(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						brak;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  returnACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ac[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandlr(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dl was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k bytedata
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(buffer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSie;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waiCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	/¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTim
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: imeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i= curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	wVersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = int_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
		printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		re¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffer,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
							printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
						//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
						++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
							//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026;//»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼Æ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtie(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returns: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[ndex] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}
//************************************
// Method: ackHandler
// FullName: ackHandler
// Access: public
// Returns: void
// Qualifier: ÊÕµ½ ack£¬ÀÛ»ıÈ·ÈÏ£¬È¡Êı¾İÖ¡µÄµÚÒ»¸ö×Ö½Ú
// ÓÉÓÚ·¢ËÍÊı¾İÊ±£¬µÚÒ»¸ö×Ö½Ú£¨ĞòÁĞºÅ£©Îª 0£¨ASCII£©Ê±·¢ËÍÊ§°Ü£¬Òò´Ë¼ÓÒ»ÁË£¬´Ë´¦ĞèÒª¼õÒ»»¹Ô­
// Parameter: char c
//************************************
void ackHandler(char c)
{
	unsigned char index = (unsigned char)c - 1; //ĞòÁĞºÅ¼õÒ»
	printf("Recv a ack of %d\n",index);
	if(curAck <= index)
	{
		for(int i= curAck; i <= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = (index + 1) % SEQ_SIZE;
	}
	else
	{
		//ack ³¬¹ıÁË×î´óÖµ£¬»Øµ½ÁË curAck µÄ×ó±ß
		for(int i = curAck;i< SEQ_SIZE;++i)
		{
			ack[i] = TRUE;
		}
		for(int i = 0; i<= index;++i)
		{
			ack[i] = TRUE;
		}
		curAck = index + 1;
	}
}
//Ö÷º¯Êı
int main(int argc, char* argv[])
{
	//¼ÓÔØÌ×½Ó×Ö¿â£¨±ØĞë£©
	WORD wVersionRequested;
	WSADATA wsaData;
	//Ì×½Ó×Ö¼ÓÔØÊ±´íÎóÌáÊ¾
	int err;
	//°æ±¾ 2.2
	VersionRequested = MAKEWORD(2, 2);
	//¼ÓÔØ dll ÎÄ¼ş Scoket ¿â
	err = WSAStartup(wVersionRequested, &wsaData);
	if(err != 0)
	{
		//ÕÒ²»µ½ winsock.dll
		printf("WSAStartup failed with error: %d\n", err);
		return -1;
	}
	if(LOBYTE(wsaData.wVersion) != 2 || HIBYTE(wsaData.wVersion) !=2)
	{
		printf("Could not find a usable version of Winsock.dll\n");
		WSACleanup();
	}
	else
	{
		printf("The Winsock 2.2 dll was found okay\n");
	}
	SOCKET sockServer = socket(AF_INET, SOCK_DGRAM,IPPROTO_UDP);
	//ÉèÖÃÌ×½Ó×ÖÎª·Ç×èÈûÄ£Ê½
	int iMode = 1; //1£º·Ç×èÈû£¬0£º×èÈû
	ioctlsocket(sockServer, FIONBIO, (u_long FAR*) &iMode);//·Ç×èÈûÉèÖÃ
	SOCKADDR_IN addrServer; //·şÎñÆ÷µØÖ·
	//addrServer.sin_addr.S_un.S_addr = inet_addr(SERVER_IP);
	// htonl => ±¾»úĞò×ª»¯ÎªÍøÂçĞò
	addrServer.sin_addr.S_un.S_addr = htonl(INADDR_ANY);//Á½Õß¾ù¿É
	addrServer.sin_family = AF_INET;
	addrServer.sin_port = htons(SERVER_PORT);
	err = bind(sockServer,(SOCKADDR*)&addrServer, sizeof(SOCKADDR));
	if(err)
	{
		err = GetLastError();
	printf("Could not bind the port %d for socket.Error code is %d\n",SERVER_PORT,err);
		WSACleanup();
		return -1;
	}
	SOCKADDR_IN addrClient; //¿Í»§¶ËµØÖ·
	int length = sizeof(SOCKADDR);
	char buffer[BUFFER_LENGTH]; //Êı¾İ·¢ËÍ½ÓÊÕ»º³åÇø
	ZeroMemory(buffer,sizeof(buffer));
	//½«²âÊÔÊı¾İ¶ÁÈëÄÚ´æ
	std::ifstream icin;
	icin.open("test.txt");
	char data[1024 * 113];
	ZeroMemory(data,sizeof(data));
	//113k byte data
	icin.read(data,1024 * 113); 
	icin.close();
	//total packet number :113
	totalPacket = sizeof(data) / 1024;
	int recvSize ;
	for(int i=0; i < SEQ_SIZE; ++i)
	{
		ack[i] = TRUE;  // ?
	}
	while(true)
	{
		//checking for command 
		//·Ç×èÈû½ÓÊÕ£¬ÈôÃ»ÓĞÊÕµ½Êı¾İ£¬·µ»ØÖµÎª-1
		recvSize  =
		recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
		if(recvSize < 0)
		{
			Sleep(200);
			continue;
		}
		printf("recv from client: %s\n",buffer);
		if(strcmp(buffer,"-time") == 0)
		{
			getCurTime(buffer);
		}
		else if(strcmp(buffer,"-quit") == 0)
		{
			strcpy_s(bufer,strlen("Good bye!") + 1,"Good bye!");
		}
		else if(strcmp(buffer,"-testgbn") == 0)
		{
			//½øÈë gbn ²âÊÔ½×¶Î
			//Ê×ÏÈ server£¨server ´¦ÓÚ 0 ×´Ì¬£©Ïò client ·¢ËÍ 205 ×´Ì¬Âë£¨server½øÈë 1 ×´Ì¬£©
			//server µÈ´ı client »Ø¸´ 200 ×´Ì¬Âë£¬Èç¹ûÊÕµ½£¨server ½øÈë 2 ×´Ì¬£©£¬Ôò¿ªÊ¼´«ÊäÎÄ¼ş£¬·ñÔòÑÓÊ±µÈ´ıÖ±ÖÁ³¬Ê±\
			//ÔÚÎÄ¼ş´«Êä½×¶Î£¬server ·¢ËÍ´°¿Ú´óĞ¡ÉèÎª
			ZeroMemory(buffer,sizeof(buffer));
			int recvSize;
			//Á¬½Ó½¨Á¢ ¼ÆÊıÆ÷
			int waitCount = 0;
			printf("Begain to test GBN protocol,please don't abort the process\n");
			//¼ÓÈëÁËÒ»¸öÎÕÊÖ½×¶Î
			//Ê×ÏÈ·şÎñÆ÷Ïò¿Í»§¶Ë·¢ËÍÒ»¸ö 205 ´óĞ¡µÄ×´Ì¬Âë£¨ÎÒ×Ô¼º¶¨ÒåµÄ£©±íÊ¾·şÎñÆ÷×¼±¸ºÃÁË£¬¿ÉÒÔ·¢ËÍÊı¾İ
			//¿Í»§¶ËÊÕµ½ 205 Ö®ºó»Ø¸´Ò»¸ö 200 ´óĞ¡µÄ×´Ì¬Âë£¬±íÊ¾¿Í»§¶Ë×¼±¸ºÃÁË£¬¿ÉÒÔ½ÓÊÕÊı¾İÁË
			//·şÎñÆ÷ÊÕµ½ 200 ×´Ì¬ÂëÖ®ºó£¬¾Í¿ªÊ¼Ê¹ÓÃ GBN ·¢ËÍÊı¾İÁË
			printf("Shake hands stage\n");
			int stage = 0;
			bool runFlag = true;
			while(runFlag)
			{
				switch(stage)
				{
					case 0://·¢ËÍ 205 ½×¶Î
						buffer[0] = 205;
						sendto(sockServer,  buffe,  strlen(buffer)+1,  0, (SOCKADDR*)&addrClient, sizeof(SOCKADDR));
						Sleep(100);
						stage = 1;
						break;
					case 1://µÈ´ı½ÓÊÕ 200 ½×¶Î£¬Ã»ÓĞÊÕµ½Ôò¼ÆÊıÆ÷+1£¬³¬Ê±Ôò·ÅÆú´Ë´Î¡°Á¬½Ó¡±£¬µÈ´ı´ÓµÚÒ»²½¿ªÊ¼
					    // sockServer ·Ç×èÈû Ì×½Ó×Ö
						recvSize  = recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							++waitCount;
							if(waitCount > 20)
							{
								runFlag = false;
								printf("Timeout error\n");
								// connected ended 
								break;
							}
							Sleep(500);
							continue;
						}
						else
						{
							if((unsigned char)buffer[0] == 200)
							{
								printf("Begin a file transfer\n");
								printf("File size is %dB, each packet is 1024B and packet total num is %d\n",sizeof(data),totalPacket);
								//initialize
								curSeq = 0;
								curAck = 0; 
								totalSeq = 0;
								waitCount = 0;
								stage = 2;
							}
						}
						break;
					case 2://Êı¾İ´«Êä½×¶Î
					//Ã¿´ÎÑ­»··¢Ò»¸öÊı¾İ°ü
						if(seqIsAvailable())
						{
							//ÒòÎª£º½ÓÊÕ¶Ë³õÊ¼»¯µÄexpectedseq = 1,  return ACK0 ±íÊ¾ ½ÓÊÜÊ§°Ü
							//ËùÒÔ·¢ËÍ¶ËĞòÁĞºÅ·¶Î§Îª£º 0~19£¬ ½ÓÊÕ¶ËĞòÁĞºÅ·¶Î§Îª: 1~20, ĞèÒª×ö¸ö×ª»¯
							//·¢ËÍ¸ø¿Í»§¶ËµÄĞòÁĞºÅ´Ó 1 ¿ªÊ¼
							buffer[0] = curSeq + 1;
							ack[curSeq] = FALSE;
							//Êı¾İ·¢ËÍµÄ¹ı³ÌÖĞÓ¦¸ÃÅĞ¶ÏÊÇ·ñ´«ÊäÍê³É
							//Îª¼ò»¯¹ı³Ì´Ë´¦²¢Î´ÊµÏÖ£¬ Èç¹ûÎ´Íê³É£¬ ĞèÒªÖØ´«£¿
							//data + 1024*totalSeq: start addr
							memcpy(&buffer[1],data + 1024 * totalSeq,1024);
							printf("send a packet with a seq of %d\n",curSeq);
							sendto(sockServer, buffer, BUFFER_LENGTH, 0,
							(SOCKADDR*)&addrClient, sizeof(SOCKADDR));
							//nextseqnum mod SEQ
							++curSeq;
							curSeq %= SEQ_SIZE;
							++totalSeq;
							Sleep(500);
						}
						//µÈ´ı Ack£¬ÈôÃ»ÓĞÊÕµ½£¬Ôò·µ»ØÖµÎª-1£¬¼ÆÊıÆ÷+1
						recvSize  =
						recvfrom(sockServer,buffer,BUFFER_LENGTH,0,((SOCKADDR*)&addrClient),&length);
						if(recvSize < 0)
						{
							waitCount++;
						//20 ´ÎµÈ´ı ack Ôò³¬Ê±ÖØ´«
							if (waitCount > 20)
							{
								timeoutHandler();
								waitCount = 0;
							}
						}
						else
						{
							//ÊÕµ½ ack
							ackHandler(buffer[0]);
							waitCount = 0;
							//¼ÆÊ±Æ÷ÇåÁã
						}
						Sleep(500);
						break;
				}
			}
		}
		sendto(sockServer, buffer, strlen(buffer)+1, 0, (SOCKADDR*)&addrClient,
		sizeof(SOCKADDR));
		Sleep(500);
	}
	//¹Ø±ÕÌ×½Ó×Ö£¬Ğ¶ÔØ¿â
	closesocket(sockServer);
	WSACleanup();
	return 0;
}


#include <stdlib.h>
#include <time.h>
#include <WinSock2.h>
#include <fstream>
#pragma comment(lib,"ws2_32.lib")
#define SERVER_PORT  12340  //¶Ë¿ÚºÅ
#define SERVER_IP  "0.0.0.0" //IP µØÖ·
const int BUFFER_LENGTH = 1026; //»º³åÇø´óĞ¡£¬£¨ÒÔÌ«ÍøÖĞ UDP µÄÊı¾İÖ¡ÖĞ°ü³¤¶ÈÓ¦Ğ¡ÓÚ 1480 ×Ö½Ú£©
const int SEND_WIND_SIZE = 10;//·¢ËÍ´°¿Ú´óĞ¡Îª 10£¬GBN ÖĞÓ¦Âú×ã W + 1 <=N£¨W Îª·¢ËÍ´°¿Ú´óĞ¡£¬N ÎªĞòÁĞºÅ¸öÊı£©
//±¾ÀıÈ¡ĞòÁĞºÅ 0...19 ¹² 20 ¸ö
//Èç¹û½«´°¿Ú´óĞ¡ÉèÎª 1£¬ÔòÎªÍ£-µÈĞ­Òé
const int SEQ_SIZE = 20; //ĞòÁĞºÅµÄ¸öÊı£¬´Ó 0~19 ¹²¼ 20 ¸ö
//ÓÉÓÚ·¢ËÍÊı¾İµÚÒ»¸ö×Ö½ÚÈç¹ûÖµÎª 0£¬ÔòÊı¾İ»á·¢ËÍÊ§°Ü
//Òò´Ë½ÓÊÕ¶ËĞòÁĞºÅÎª 1~20£¬Óë·¢ËÍ¶ËÒ»Ò»¶ÔÓ¦
BOOL ack[SEQ_SIZE];//ÊÕµ½ ack Çé¿ö£¬¶ÔÓ¦ 0~19 µÄ ack, ÀÛ¼ÆÈ·ÈÏ
int curSeq;//µ±Ç°Êı¾İ°üµÄ seq curSeq => nextseqnum
int curAck;//µ±Ç°µÈ´ıÈ·ÈÏµÄ ack => base 
int totalSeq;//ÊÕµ½µÄ°üµÄ×ÜÊı
int totalPacket;//ĞèÒª·¢ËÍµÄ°ü×ÜÊı
//************************************
// Method: getCurTime
// FullName: getCurTime
// Access: public
// Returns: void
// Qualifier: »ñÈ¡µ±Ç°ÏµÍ³Ê±¼ä£¬½á¹û´æÈë ptime ÖĞ
// Parameter: char * ptime
//************************************
void getCurTime(char *ptime)
{
	char buffer[128];
	memset(buffer,0,sizeof(buffer));
	time_t c_time;
	struct tm *p;
	time(&c_time);
	p = localtime(&c_time);
	sprintf_s(buffer,"%d/%d/%d %d:%d:%d",
	p->tm_year + 1900,
	p->tm_mon,
	p->tm_mday,
	p->tm_hour,
	p->tm_min,
	p->tm_sec);
	strcpy_s(ptime,sizeof(buffer),buffer);
}
//************************************
// Method: seqIsAvailable
// FullName: seqIsAvailable
// Access: public
// Returs: bool
// Qualifier: µ±Ç°ĞòÁĞºÅ curSeq ÊÇ·ñ¿ÉÓÃ
//************************************
bool seqIsAvailable()
{
	int step;
	step = curSeq - curAck;
	step = step >= 0 ? step : step + SEQ_SIZE;
	//ĞòÁĞºÅÊÇ·ñÔÚµ±Ç°·¢ËÍ´°¿ÚÖ®ÄÚ
	if(step >= SEND_WIND_SIZE)
	{
		return false;
	}
	if(ack[curSeq])
	{
		return true;
	}
	return false;
}
//************************************
// Method: timeoutHandler
// FullName: timeoutHandler
// Access: public
// Returns: void
// Qualifier: ³¬Ê±ÖØ´«´¦Àíº¯Êı£¬»¬¶¯´°¿ÚÄÚµÄÊı¾İÖ¡¶¼ÒªÖØ´«
//************************************
void timeoutHandler(){
	printf("Timer out error.\n");
	int index;
	for(int i = 0;i< SEND_WIND_SIZE;++i)
	{
		index = (i + curAck) % SEQ_SIZE;
		ack[index] = TRUE;
	}
	totalSeq -= SEND_WIND_SIZE;
	curSeq = curAck;
}